//requests and responses for XDCR rest APIs 

package protobuf;

// certain responses, e.g., response to ChangeGlobalSettingsRequest, are empty messages
message EmptyMessage{
}

message CreateReplicationRequest {
 	required string    fromBucket        = 1; // name of source bucket
 	required string    toCluster         = 2; // name of the remote cluster reference
 	required string    toBucket          = 3; // name of target bucket
 	optional string    filterName        = 4; // name of filter used for the replication
 	optional ReplicationSettings  settings          = 6; // replication settings
 	optional bool      forward           = 7 [default = true]; // flag indicating whether the request should be forwarded to other XDCR nodes
}

message CreateReplicationResponse {
 	required string    id       		 = 1; // id of the created replication
 	required string    database          = 2; // name of the database
}

message DeleteReplicationRequest {
 	optional string    id     		     = 1; // id of the replication to delete
 	optional bool      forward           = 2 [default = true]; // flag indicating whether the request should be forwarded to other XDCR nodes
}

message ViewInternalSettingsRequest {
}

message ViewInternalSettingsResponse {
	required InternalSettings  settings          = 1; // internal settings 
}

message InternalSettings {
 	optional string    protocol        	  = 1; // version of XDCR protocol 
 	optional uint32    xdcrCheckpointInterval = 2; // checkpoint interval (in seconds)
 	optional uint32    xdcrWorkerBatchSize    = 3; // number of documents in a batch
 	optional uint32    xdcrDocBatchSizeKb     = 4; // size of a batch (in KB)
 	optional uint32    xdcrFailureRestartInterval     = 5; // internal for restarting failed XDCR (in seconds)
 	optional uint32    xdcrOptimisticReplicationThreshold = 6; // threshold size of compressed document (in bytes)
 	optional uint32    httpConnections     = 7; // number of maximum simultaneous HTTP connections 
 	optional uint32    xdcrSourceNozzlePerNode = 8; // number of source nozzles per source node
 	optional uint32    xdcrTargetNozzlePerNode = 9; // number of outgoing nozzles per target node
 	optional uint32    xdcrMaxExpectedReplicationLag = 10; // max replication lag (in ms) that can be tolerated
 	optional uint32    xdcrTimeoutPercentageCap = 11; // maximum timeout percentage allowed. pipeline is considered not healthy when it is exceeded 
}

message ReplicationSettings {
	optional InternalSettings  internalSettings = 1; // internal settings
 	optional string    xdcrFilterExpression   = 2; // filter expression
 	enum ReplicationType {
 	    capi = 0;  // use CAPI nozzles
 		xmem = 1;  // use XMEM nozzles
 	}
 	optional ReplicationType      xdcrReplicationType  = 3 [default = capi]; // relication type. xmem vs. capi
	optional bool      active                 = 4; // flag indicating whether the replication is active
}

// request to change global settings of all replications in the cluster
message ChangeGlobalSettingsRequest { 
	required InternalSettings  settings          = 1; // settings to be set/updated
}

// request to change settings of an individual replication
message ChangeReplicationSettingsRequest { 
	required string    id         	     = 1; // replication id 
	required ReplicationSettings  settings          = 2; // settings to be set/updated
}

// request to change internal settings of all replications in the cluster. 
// effectively the same as ChangeGlobalSettingsRequest but with a different url
message ChangeInternalSettingsRequest { 
	required InternalSettings  settings          = 1; // settings to be set/updated
}

message GetStatisticsRequest {
	required string    uuid              = 1; // uuid of the remote cluster 
	required string    fromBucket        = 2; // name of source bucket
	required string    toBucket          = 3; // name of target bucket
	optional string    filterName        = 4; // name of filter used for the replication
	enum Stats {
		docs_written = 0; // number of documents written to destination cluster via XDCR
		data_replicated = 1; // size of data replicated in bytes
		changes_left = 2; // number of updates still pending replication
		docs_checked = 3; // number of documents checkpointed for changes
		num_checkpoints = 4; // number of checkpoints issued in replication queue
		num_failedckpts = 5; // number of checkpoints failed during replication
		size_rep_queue = 6; // size of replication queue in bytes
		time_committing = 7; // seconds elapsed during replication
		bandwidth_usage = 8; // bandwidth used during replication
		docs_lanecy_aggr = 9; // aggregate time waiting to send changes to destination cluster in milliseconds
		docs_latency_wt = 10; // weighted average latency for sending replicated changes to destination cluster
		docs_req_queue = 11; // Number of documents in replication queue
		meta_latency_aggr = 12; // aggregate time to request and receive metadata about documents
		meta_latency_wt = 13; // weighted average time for requesting document metadata
		rate_replication = 14; // bytes replicated per second
		docs_opt_repd = 15; // number of docs sent optimistically
		active_vbreps = 16;
		waiting_vbreps = 17;
		time_working = 18;
		timeout_percentage_map = 19;  // The map of vbucket id and  the percentage of timed-out data for this VBucket during this statistics interval		
	}
	required Stats    stats         = 5; // name of statistics, e.g., docs_written
}

/* TODO do we need to have one response message for each statistics type?
message GetStatisticsResponse {
}*/


