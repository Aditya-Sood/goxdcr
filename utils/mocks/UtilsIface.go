package mocks

import base "github.com/couchbase/goxdcr/base"
import couchbase "github.com/couchbase/go-couchbase"
import expvar "expvar"
import gomemcached "github.com/couchbase/gomemcached"
import http "net/http"
import log "github.com/couchbase/goxdcr/log"
import memcached "github.com/couchbase/gomemcached/client"
import mock "github.com/stretchr/testify/mock"
import regexp "regexp"
import time "time"

// UtilsIface is an autogenerated mock type for the UtilsIface type
type UtilsIface struct {
	mock.Mock
}

// BucketInfoParseError provides a mock function with given fields: bucketInfo, logger
func (_m *UtilsIface) BucketInfoParseError(bucketInfo map[string]interface{}, logger *log.CommonLogger) error {
	ret := _m.Called(bucketInfo, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) error); ok {
		r0 = rf(bucketInfo, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BucketNotFoundError provides a mock function with given fields: bucketName
func (_m *UtilsIface) BucketNotFoundError(bucketName string) error {
	ret := _m.Called(bucketName)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(bucketName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BucketPassword provides a mock function with given fields: hostAddr, bucketName, username, password, certificate, sanInCertificate, logger
func (_m *UtilsIface) BucketPassword(hostAddr string, bucketName string, username string, password string, certificate []byte, sanInCertificate bool, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, string, string, []byte, bool, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, []byte, bool, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BucketUUID provides a mock function with given fields: hostAddr, bucketName, username, password, certificate, sanInCertificate, logger
func (_m *UtilsIface) BucketUUID(hostAddr string, bucketName string, username string, password string, certificate []byte, sanInCertificate bool, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, string, string, []byte, bool, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, []byte, bool, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BucketValidationInfo provides a mock function with given fields: hostAddr, bucketName, username, password, certificate, sanInCertificate, logger
func (_m *UtilsIface) BucketValidationInfo(hostAddr string, bucketName string, username string, password string, certificate []byte, sanInCertificate bool, logger *log.CommonLogger) (map[string]interface{}, string, string, string, string, map[string][]uint16, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, string, []byte, bool, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(string, string, string, string, []byte, bool, *log.CommonLogger) string); ok {
		r1 = rf(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 string
	if rf, ok := ret.Get(2).(func(string, string, string, string, []byte, bool, *log.CommonLogger) string); ok {
		r2 = rf(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)
	} else {
		r2 = ret.Get(2).(string)
	}

	var r3 string
	if rf, ok := ret.Get(3).(func(string, string, string, string, []byte, bool, *log.CommonLogger) string); ok {
		r3 = rf(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)
	} else {
		r3 = ret.Get(3).(string)
	}

	var r4 string
	if rf, ok := ret.Get(4).(func(string, string, string, string, []byte, bool, *log.CommonLogger) string); ok {
		r4 = rf(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)
	} else {
		r4 = ret.Get(4).(string)
	}

	var r5 map[string][]uint16
	if rf, ok := ret.Get(5).(func(string, string, string, string, []byte, bool, *log.CommonLogger) map[string][]uint16); ok {
		r5 = rf(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)
	} else {
		if ret.Get(5) != nil {
			r5 = ret.Get(5).(map[string][]uint16)
		}
	}

	var r6 error
	if rf, ok := ret.Get(6).(func(string, string, string, string, []byte, bool, *log.CommonLogger) error); ok {
		r6 = rf(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)
	} else {
		r6 = ret.Error(6)
	}

	return r0, r1, r2, r3, r4, r5, r6
}

// CheckWhetherClusterIsESBasedOnBucketInfo provides a mock function with given fields: bucketInfo
func (_m *UtilsIface) CheckWhetherClusterIsESBasedOnBucketInfo(bucketInfo map[string]interface{}) bool {
	ret := _m.Called(bucketInfo)

	var r0 bool
	if rf, ok := ret.Get(0).(func(map[string]interface{}) bool); ok {
		r0 = rf(bucketInfo)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// ComposeHELORequest provides a mock function with given fields: userAgent, enableXattr
func (_m *UtilsIface) ComposeHELORequest(userAgent string, enableXattr bool) *gomemcached.MCRequest {
	ret := _m.Called(userAgent, enableXattr)

	var r0 *gomemcached.MCRequest
	if rf, ok := ret.Get(0).(func(string, bool) *gomemcached.MCRequest); ok {
		r0 = rf(userAgent, enableXattr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gomemcached.MCRequest)
		}
	}

	return r0
}

// ConstructHttpRequest provides a mock function with given fields: baseURL, path, preservePathEncoding, username, password, certificate, httpCommand, contentType, body, logger
func (_m *UtilsIface) ConstructHttpRequest(baseURL string, path string, preservePathEncoding bool, username string, password string, certificate []byte, httpCommand string, contentType string, body []byte, logger *log.CommonLogger) (*http.Request, string, error) {
	ret := _m.Called(baseURL, path, preservePathEncoding, username, password, certificate, httpCommand, contentType, body, logger)

	var r0 *http.Request
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, []byte, string, string, []byte, *log.CommonLogger) *http.Request); ok {
		r0 = rf(baseURL, path, preservePathEncoding, username, password, certificate, httpCommand, contentType, body, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Request)
		}
	}

	var r1 string
	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, []byte, string, string, []byte, *log.CommonLogger) string); ok {
		r1 = rf(baseURL, path, preservePathEncoding, username, password, certificate, httpCommand, contentType, body, logger)
	} else {
		r1 = ret.Get(1).(string)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string, string, bool, string, string, []byte, string, string, []byte, *log.CommonLogger) error); ok {
		r2 = rf(baseURL, path, preservePathEncoding, username, password, certificate, httpCommand, contentType, body, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// EncodeHttpRequest provides a mock function with given fields: req
func (_m *UtilsIface) EncodeHttpRequest(req *http.Request) ([]byte, error) {
	ret := _m.Called(req)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(*http.Request) []byte); ok {
		r0 = rf(req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*http.Request) error); ok {
		r1 = rf(req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EncodeHttpRequestHeader provides a mock function with given fields: reqBytes, key, value
func (_m *UtilsIface) EncodeHttpRequestHeader(reqBytes []byte, key string, value string) []byte {
	ret := _m.Called(reqBytes, key, value)

	var r0 []byte
	if rf, ok := ret.Get(0).(func([]byte, string, string) []byte); ok {
		r0 = rf(reqBytes, key, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// EncodeMapIntoByteArray provides a mock function with given fields: data
func (_m *UtilsIface) EncodeMapIntoByteArray(data map[string]interface{}) ([]byte, error) {
	ret := _m.Called(data)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(map[string]interface{}) []byte); ok {
		r0 = rf(data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EnforcePrefix provides a mock function with given fields: prefix, str
func (_m *UtilsIface) EnforcePrefix(prefix string, str string) string {
	ret := _m.Called(prefix, str)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(prefix, str)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetBucketInfo provides a mock function with given fields: hostAddr, bucketName, username, password, certificate, sanInCertificate, logger
func (_m *UtilsIface) GetBucketInfo(hostAddr string, bucketName string, username string, password string, certificate []byte, sanInCertificate bool, logger *log.CommonLogger) (map[string]interface{}, error) {
	ret := _m.Called(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, string, []byte, bool, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, []byte, bool, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, bucketName, username, password, certificate, sanInCertificate, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBucketPasswordFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo, logger
func (_m *UtilsIface) GetBucketPasswordFromBucketInfo(bucketName string, bucketInfo map[string]interface{}, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(bucketName, bucketInfo, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(bucketName, bucketInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(bucketName, bucketInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBucketTypeFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo
func (_m *UtilsIface) GetBucketTypeFromBucketInfo(bucketName string, bucketInfo map[string]interface{}) (string, error) {
	ret := _m.Called(bucketName, bucketInfo)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) string); ok {
		r0 = rf(bucketName, bucketInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}) error); ok {
		r1 = rf(bucketName, bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBucketUuidFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo, logger
func (_m *UtilsIface) GetBucketUuidFromBucketInfo(bucketName string, bucketInfo map[string]interface{}, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(bucketName, bucketInfo, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(bucketName, bucketInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(bucketName, bucketInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBuckets provides a mock function with given fields: hostAddr, username, password, certificate, sanInCertificate, logger
func (_m *UtilsIface) GetBuckets(hostAddr string, username string, password string, certificate []byte, sanInCertificate bool, logger *log.CommonLogger) (map[string]string, error) {
	ret := _m.Called(hostAddr, username, password, certificate, sanInCertificate, logger)

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func(string, string, string, []byte, bool, *log.CommonLogger) map[string]string); ok {
		r0 = rf(hostAddr, username, password, certificate, sanInCertificate, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, []byte, bool, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, username, password, certificate, sanInCertificate, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterCompatibilityFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo, logger
func (_m *UtilsIface) GetClusterCompatibilityFromBucketInfo(bucketName string, bucketInfo map[string]interface{}, logger *log.CommonLogger) (int, error) {
	ret := _m.Called(bucketName, bucketInfo, logger)

	var r0 int
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, *log.CommonLogger) int); ok {
		r0 = rf(bucketName, bucketInfo, logger)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(bucketName, bucketInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterCompatibilityFromNodeList provides a mock function with given fields: nodeList
func (_m *UtilsIface) GetClusterCompatibilityFromNodeList(nodeList []interface{}) (int, error) {
	ret := _m.Called(nodeList)

	var r0 int
	if rf, ok := ret.Get(0).(func([]interface{}) int); ok {
		r0 = rf(nodeList)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]interface{}) error); ok {
		r1 = rf(nodeList)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterInfo provides a mock function with given fields: hostAddr, path, username, password, certificate, sanInCertificate, logger
func (_m *UtilsIface) GetClusterInfo(hostAddr string, path string, username string, password string, certificate []byte, sanInCertificate bool, logger *log.CommonLogger) (map[string]interface{}, error) {
	ret := _m.Called(hostAddr, path, username, password, certificate, sanInCertificate, logger)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, string, []byte, bool, *log.CommonLogger) map[string]interface{}); ok {
		r0 = rf(hostAddr, path, username, password, certificate, sanInCertificate, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, []byte, bool, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, path, username, password, certificate, sanInCertificate, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterUUID provides a mock function with given fields: hostAddr, username, password, certificate, sanInCertificate, logger
func (_m *UtilsIface) GetClusterUUID(hostAddr string, username string, password string, certificate []byte, sanInCertificate bool, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(hostAddr, username, password, certificate, sanInCertificate, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, string, []byte, bool, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, username, password, certificate, sanInCertificate, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, []byte, bool, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, username, password, certificate, sanInCertificate, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterUUIDAndNodeListWithMinInfo provides a mock function with given fields: hostAddr, username, password, certificate, sanInCertificate, logger
func (_m *UtilsIface) GetClusterUUIDAndNodeListWithMinInfo(hostAddr string, username string, password string, certificate []byte, sanInCertificate bool, logger *log.CommonLogger) (string, []interface{}, error) {
	ret := _m.Called(hostAddr, username, password, certificate, sanInCertificate, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, string, []byte, bool, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, username, password, certificate, sanInCertificate, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 []interface{}
	if rf, ok := ret.Get(1).(func(string, string, string, []byte, bool, *log.CommonLogger) []interface{}); ok {
		r1 = rf(hostAddr, username, password, certificate, sanInCertificate, logger)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]interface{})
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string, string, string, []byte, bool, *log.CommonLogger) error); ok {
		r2 = rf(hostAddr, username, password, certificate, sanInCertificate, logger)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetClusterUUIDFromDefaultPoolInfo provides a mock function with given fields: defaultPoolInfo, logger
func (_m *UtilsIface) GetClusterUUIDFromDefaultPoolInfo(defaultPoolInfo map[string]interface{}, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(defaultPoolInfo, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(defaultPoolInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(defaultPoolInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetClusterUUIDFromURI provides a mock function with given fields: uri
func (_m *UtilsIface) GetClusterUUIDFromURI(uri string) (string, error) {
	ret := _m.Called(uri)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(uri)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(uri)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConflictResolutionTypeFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo
func (_m *UtilsIface) GetConflictResolutionTypeFromBucketInfo(bucketName string, bucketInfo map[string]interface{}) (string, error) {
	ret := _m.Called(bucketName, bucketInfo)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) string); ok {
		r0 = rf(bucketName, bucketInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}) error); ok {
		r1 = rf(bucketName, bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetEvictionPolicyFromBucketInfo provides a mock function with given fields: bucketName, bucketInfo
func (_m *UtilsIface) GetEvictionPolicyFromBucketInfo(bucketName string, bucketInfo map[string]interface{}) (string, error) {
	ret := _m.Called(bucketName, bucketInfo)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}) string); ok {
		r0 = rf(bucketName, bucketInfo)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}) error); ok {
		r1 = rf(bucketName, bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHostAddr provides a mock function with given fields: hostName, port
func (_m *UtilsIface) GetHostAddr(hostName string, port uint16) string {
	ret := _m.Called(hostName, port)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, uint16) string); ok {
		r0 = rf(hostName, port)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetHostAddrFromNodeInfo provides a mock function with given fields: adminHostAddr, nodeInfo, logger
func (_m *UtilsIface) GetHostAddrFromNodeInfo(adminHostAddr string, nodeInfo map[string]interface{}, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(adminHostAddr, nodeInfo, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(adminHostAddr, nodeInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(adminHostAddr, nodeInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHostName provides a mock function with given fields: hostAddr
func (_m *UtilsIface) GetHostName(hostAddr string) string {
	ret := _m.Called(hostAddr)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(hostAddr)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetHostNameFromNodeInfo provides a mock function with given fields: adminHostAddr, nodeInfo, logger
func (_m *UtilsIface) GetHostNameFromNodeInfo(adminHostAddr string, nodeInfo map[string]interface{}, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(adminHostAddr, nodeInfo, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, map[string]interface{}, *log.CommonLogger) string); ok {
		r0 = rf(adminHostAddr, nodeInfo, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(adminHostAddr, nodeInfo, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHttpClient provides a mock function with given fields: certificate, san_in_certificate, ssl_con_str, logger
func (_m *UtilsIface) GetHttpClient(certificate []byte, san_in_certificate bool, ssl_con_str string, logger *log.CommonLogger) (*http.Client, error) {
	ret := _m.Called(certificate, san_in_certificate, ssl_con_str, logger)

	var r0 *http.Client
	if rf, ok := ret.Get(0).(func([]byte, bool, string, *log.CommonLogger) *http.Client); ok {
		r0 = rf(certificate, san_in_certificate, ssl_con_str, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*http.Client)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]byte, bool, string, *log.CommonLogger) error); ok {
		r1 = rf(certificate, san_in_certificate, ssl_con_str, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetIntSettingFromSettings provides a mock function with given fields: settings, settingName
func (_m *UtilsIface) GetIntSettingFromSettings(settings map[string]interface{}, settingName string) (int, error) {
	ret := _m.Called(settings, settingName)

	var r0 int
	if rf, ok := ret.Get(0).(func(map[string]interface{}, string) int); ok {
		r0 = rf(settings, settingName)
	} else {
		r0 = ret.Get(0).(int)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(map[string]interface{}, string) error); ok {
		r1 = rf(settings, settingName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLocalBuckets provides a mock function with given fields: hostAddr, logger
func (_m *UtilsIface) GetLocalBuckets(hostAddr string, logger *log.CommonLogger) (map[string]string, error) {
	ret := _m.Called(hostAddr, logger)

	var r0 map[string]string
	if rf, ok := ret.Get(0).(func(string, *log.CommonLogger) map[string]string); ok {
		r0 = rf(hostAddr, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMapFromExpvarMap provides a mock function with given fields: expvarMap
func (_m *UtilsIface) GetMapFromExpvarMap(expvarMap *expvar.Map) map[string]interface{} {
	ret := _m.Called(expvarMap)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(*expvar.Map) map[string]interface{}); ok {
		r0 = rf(expvarMap)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	return r0
}

// GetMatchedKeys provides a mock function with given fields: expression, keys
func (_m *UtilsIface) GetMatchedKeys(expression string, keys []string) (map[string][][]int, error) {
	ret := _m.Called(expression, keys)

	var r0 map[string][][]int
	if rf, ok := ret.Get(0).(func(string, []string) map[string][][]int); ok {
		r0 = rf(expression, keys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][][]int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []string) error); ok {
		r1 = rf(expression, keys)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMemcachedClient provides a mock function with given fields: serverAddr, bucketName, kv_mem_clients, userAgent, logger
func (_m *UtilsIface) GetMemcachedClient(serverAddr string, bucketName string, kv_mem_clients map[string]memcached.ClientIface, userAgent string, logger *log.CommonLogger) (memcached.ClientIface, error) {
	ret := _m.Called(serverAddr, bucketName, kv_mem_clients, userAgent, logger)

	var r0 memcached.ClientIface
	if rf, ok := ret.Get(0).(func(string, string, map[string]memcached.ClientIface, string, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, bucketName, kv_mem_clients, userAgent, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, map[string]memcached.ClientIface, string, *log.CommonLogger) error); ok {
		r1 = rf(serverAddr, bucketName, kv_mem_clients, userAgent, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMemcachedConnection provides a mock function with given fields: serverAddr, bucketName, userAgent, logger
func (_m *UtilsIface) GetMemcachedConnection(serverAddr string, bucketName string, userAgent string, logger *log.CommonLogger) (memcached.ClientIface, error) {
	ret := _m.Called(serverAddr, bucketName, userAgent, logger)

	var r0 memcached.ClientIface
	if rf, ok := ret.Get(0).(func(string, string, string, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, bucketName, userAgent, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, *log.CommonLogger) error); ok {
		r1 = rf(serverAddr, bucketName, userAgent, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMemcachedSSLPortMap provides a mock function with given fields: hostName, username, password, certificate, sanInCertificate, bucket, logger
func (_m *UtilsIface) GetMemcachedSSLPortMap(hostName string, username string, password string, certificate []byte, sanInCertificate bool, bucket string, logger *log.CommonLogger) (map[string]uint16, error) {
	ret := _m.Called(hostName, username, password, certificate, sanInCertificate, bucket, logger)

	var r0 map[string]uint16
	if rf, ok := ret.Get(0).(func(string, string, string, []byte, bool, string, *log.CommonLogger) map[string]uint16); ok {
		r0 = rf(hostName, username, password, certificate, sanInCertificate, bucket, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]uint16)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, []byte, bool, string, *log.CommonLogger) error); ok {
		r1 = rf(hostName, username, password, certificate, sanInCertificate, bucket, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNodeListFromInfoMap provides a mock function with given fields: infoMap, logger
func (_m *UtilsIface) GetNodeListFromInfoMap(infoMap map[string]interface{}, logger *log.CommonLogger) ([]interface{}, error) {
	ret := _m.Called(infoMap, logger)

	var r0 []interface{}
	if rf, ok := ret.Get(0).(func(map[string]interface{}, *log.CommonLogger) []interface{}); ok {
		r0 = rf(infoMap, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(map[string]interface{}, *log.CommonLogger) error); ok {
		r1 = rf(infoMap, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNodeListWithFullInfo provides a mock function with given fields: hostAddr, username, password, certificate, sanInCertificate, logger
func (_m *UtilsIface) GetNodeListWithFullInfo(hostAddr string, username string, password string, certificate []byte, sanInCertificate bool, logger *log.CommonLogger) ([]interface{}, error) {
	ret := _m.Called(hostAddr, username, password, certificate, sanInCertificate, logger)

	var r0 []interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, []byte, bool, *log.CommonLogger) []interface{}); ok {
		r0 = rf(hostAddr, username, password, certificate, sanInCertificate, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, []byte, bool, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, username, password, certificate, sanInCertificate, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNodeListWithMinInfo provides a mock function with given fields: hostAddr, username, password, certificate, sanInCertificate, logger
func (_m *UtilsIface) GetNodeListWithMinInfo(hostAddr string, username string, password string, certificate []byte, sanInCertificate bool, logger *log.CommonLogger) ([]interface{}, error) {
	ret := _m.Called(hostAddr, username, password, certificate, sanInCertificate, logger)

	var r0 []interface{}
	if rf, ok := ret.Get(0).(func(string, string, string, []byte, bool, *log.CommonLogger) []interface{}); ok {
		r0 = rf(hostAddr, username, password, certificate, sanInCertificate, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, []byte, bool, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, username, password, certificate, sanInCertificate, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNodeNameListFromNodeList provides a mock function with given fields: nodeList, connStr, logger
func (_m *UtilsIface) GetNodeNameListFromNodeList(nodeList []interface{}, connStr string, logger *log.CommonLogger) ([]string, error) {
	ret := _m.Called(nodeList, connStr, logger)

	var r0 []string
	if rf, ok := ret.Get(0).(func([]interface{}, string, *log.CommonLogger) []string); ok {
		r0 = rf(nodeList, connStr, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func([]interface{}, string, *log.CommonLogger) error); ok {
		r1 = rf(nodeList, connStr, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNonExistentBucketError provides a mock function with given fields:
func (_m *UtilsIface) GetNonExistentBucketError() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetPortNumber provides a mock function with given fields: hostAddr
func (_m *UtilsIface) GetPortNumber(hostAddr string) (uint16, error) {
	ret := _m.Called(hostAddr)

	var r0 uint16
	if rf, ok := ret.Get(0).(func(string) uint16); ok {
		r0 = rf(hostAddr)
	} else {
		r0 = ret.Get(0).(uint16)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(hostAddr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRemoteMemcachedConnection provides a mock function with given fields: serverAddr, username, password, bucketName, userAgent, plainAuth, logger
func (_m *UtilsIface) GetRemoteMemcachedConnection(serverAddr string, username string, password string, bucketName string, userAgent string, plainAuth bool, logger *log.CommonLogger) (memcached.ClientIface, error) {
	ret := _m.Called(serverAddr, username, password, bucketName, userAgent, plainAuth, logger)

	var r0 memcached.ClientIface
	if rf, ok := ret.Get(0).(func(string, string, string, string, string, bool, *log.CommonLogger) memcached.ClientIface); ok {
		r0 = rf(serverAddr, username, password, bucketName, userAgent, plainAuth, logger)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(memcached.ClientIface)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, string, string, string, bool, *log.CommonLogger) error); ok {
		r1 = rf(serverAddr, username, password, bucketName, userAgent, plainAuth, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSSLPort provides a mock function with given fields: hostAddr, logger
func (_m *UtilsIface) GetSSLPort(hostAddr string, logger *log.CommonLogger) (uint16, error, bool) {
	ret := _m.Called(hostAddr, logger)

	var r0 uint16
	if rf, ok := ret.Get(0).(func(string, *log.CommonLogger) uint16); ok {
		r0 = rf(hostAddr, logger)
	} else {
		r0 = ret.Get(0).(uint16)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, logger)
	} else {
		r1 = ret.Error(1)
	}

	var r2 bool
	if rf, ok := ret.Get(2).(func(string, *log.CommonLogger) bool); ok {
		r2 = rf(hostAddr, logger)
	} else {
		r2 = ret.Get(2).(bool)
	}

	return r0, r1, r2
}

// GetServerVBucketsMap provides a mock function with given fields: connStr, bucketName, bucketInfo
func (_m *UtilsIface) GetServerVBucketsMap(connStr string, bucketName string, bucketInfo map[string]interface{}) (map[string][]uint16, error) {
	ret := _m.Called(connStr, bucketName, bucketInfo)

	var r0 map[string][]uint16
	if rf, ok := ret.Get(0).(func(string, string, map[string]interface{}) map[string][]uint16); ok {
		r0 = rf(connStr, bucketName, bucketInfo)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]uint16)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, map[string]interface{}) error); ok {
		r1 = rf(connStr, bucketName, bucketInfo)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSettingFromSettings provides a mock function with given fields: settings, settingName
func (_m *UtilsIface) GetSettingFromSettings(settings map[string]interface{}, settingName string) interface{} {
	ret := _m.Called(settings, settingName)

	var r0 interface{}
	if rf, ok := ret.Get(0).(func(map[string]interface{}, string) interface{}); ok {
		r0 = rf(settings, settingName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	return r0
}

// GetStringSettingFromSettings provides a mock function with given fields: settings, settingName
func (_m *UtilsIface) GetStringSettingFromSettings(settings map[string]interface{}, settingName string) (string, error) {
	ret := _m.Called(settings, settingName)

	var r0 string
	if rf, ok := ret.Get(0).(func(map[string]interface{}, string) string); ok {
		r0 = rf(settings, settingName)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(map[string]interface{}, string) error); ok {
		r1 = rf(settings, settingName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HttpsHostAddr provides a mock function with given fields: hostAddr, logger
func (_m *UtilsIface) HttpsHostAddr(hostAddr string, logger *log.CommonLogger) (string, error, bool) {
	ret := _m.Called(hostAddr, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, *log.CommonLogger) string); ok {
		r0 = rf(hostAddr, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, *log.CommonLogger) error); ok {
		r1 = rf(hostAddr, logger)
	} else {
		r1 = ret.Error(1)
	}

	var r2 bool
	if rf, ok := ret.Get(2).(func(string, *log.CommonLogger) bool); ok {
		r2 = rf(hostAddr, logger)
	} else {
		r2 = ret.Get(2).(bool)
	}

	return r0, r1, r2
}

// InvalidRuneIndexErrorMessage provides a mock function with given fields: key, index
func (_m *UtilsIface) InvalidRuneIndexErrorMessage(key string, index int) string {
	ret := _m.Called(key, index)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, int) string); ok {
		r0 = rf(key, index)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// InvokeRestWithRetry provides a mock function with given fields: baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry
func (_m *UtilsIface) InvokeRestWithRetry(baseURL string, path string, preservePathEncoding bool, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, client *http.Client, keep_client_alive bool, logger *log.CommonLogger, num_retry int) (error, int, *http.Client) {
	ret := _m.Called(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) error); ok {
		r0 = rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		r0 = ret.Error(0)
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) int); ok {
		r1 = rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 *http.Client
	if rf, ok := ret.Get(2).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) *http.Client); ok {
		r2 = rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(*http.Client)
		}
	}

	return r0, r1, r2
}

// InvokeRestWithRetryWithAuth provides a mock function with given fields: baseURL, path, preservePathEncoding, username, password, certificate, san_in_certificate, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry
func (_m *UtilsIface) InvokeRestWithRetryWithAuth(baseURL string, path string, preservePathEncoding bool, username string, password string, certificate []byte, san_in_certificate bool, insecureSkipVerify bool, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, client *http.Client, keep_client_alive bool, logger *log.CommonLogger, num_retry int) (error, int, *http.Client) {
	ret := _m.Called(baseURL, path, preservePathEncoding, username, password, certificate, san_in_certificate, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, []byte, bool, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) error); ok {
		r0 = rf(baseURL, path, preservePathEncoding, username, password, certificate, san_in_certificate, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		r0 = ret.Error(0)
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, []byte, bool, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) int); ok {
		r1 = rf(baseURL, path, preservePathEncoding, username, password, certificate, san_in_certificate, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 *http.Client
	if rf, ok := ret.Get(2).(func(string, string, bool, string, string, []byte, bool, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger, int) *http.Client); ok {
		r2 = rf(baseURL, path, preservePathEncoding, username, password, certificate, san_in_certificate, insecureSkipVerify, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger, num_retry)
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).(*http.Client)
		}
	}

	return r0, r1, r2
}

// IsSeriousNetError provides a mock function with given fields: err
func (_m *UtilsIface) IsSeriousNetError(err error) bool {
	ret := _m.Called(err)

	var r0 bool
	if rf, ok := ret.Get(0).(func(error) bool); ok {
		r0 = rf(err)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// LocalBucket provides a mock function with given fields: localConnectStr, bucketName
func (_m *UtilsIface) LocalBucket(localConnectStr string, bucketName string) (*couchbase.Bucket, error) {
	ret := _m.Called(localConnectStr, bucketName)

	var r0 *couchbase.Bucket
	if rf, ok := ret.Get(0).(func(string, string) *couchbase.Bucket); ok {
		r0 = rf(localConnectStr, bucketName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*couchbase.Bucket)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(localConnectStr, bucketName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalBucketPassword provides a mock function with given fields: local_connStr, bucketName, logger
func (_m *UtilsIface) LocalBucketPassword(local_connStr string, bucketName string, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(local_connStr, bucketName, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, *log.CommonLogger) string); ok {
		r0 = rf(local_connStr, bucketName, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, *log.CommonLogger) error); ok {
		r1 = rf(local_connStr, bucketName, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalBucketUUID provides a mock function with given fields: local_connStr, bucketName, logger
func (_m *UtilsIface) LocalBucketUUID(local_connStr string, bucketName string, logger *log.CommonLogger) (string, error) {
	ret := _m.Called(local_connStr, bucketName, logger)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string, *log.CommonLogger) string); ok {
		r0 = rf(local_connStr, bucketName, logger)
	} else {
		r0 = ret.Get(0).(string)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string, *log.CommonLogger) error); ok {
		r1 = rf(local_connStr, bucketName, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalPool provides a mock function with given fields: localConnectStr
func (_m *UtilsIface) LocalPool(localConnectStr string) (couchbase.Pool, error) {
	ret := _m.Called(localConnectStr)

	var r0 couchbase.Pool
	if rf, ok := ret.Get(0).(func(string) couchbase.Pool); ok {
		r0 = rf(localConnectStr)
	} else {
		r0 = ret.Get(0).(couchbase.Pool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(localConnectStr)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewEnhancedError provides a mock function with given fields: msg, err
func (_m *UtilsIface) NewEnhancedError(msg string, err error) error {
	ret := _m.Called(msg, err)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, error) error); ok {
		r0 = rf(msg, err)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ParseHighSeqnoAndVBUuidFromStats provides a mock function with given fields: vbnos, stats_map, high_seqno_and_vbuuid_map
func (_m *UtilsIface) ParseHighSeqnoAndVBUuidFromStats(vbnos []uint16, stats_map map[string]string, high_seqno_and_vbuuid_map map[uint16][]uint64) {
	_m.Called(vbnos, stats_map, high_seqno_and_vbuuid_map)
}

// ParseHighSeqnoStat provides a mock function with given fields: vbnos, stats_map, highseqno_map
func (_m *UtilsIface) ParseHighSeqnoStat(vbnos []uint16, stats_map map[string]string, highseqno_map map[uint16]uint64) {
	_m.Called(vbnos, stats_map, highseqno_map)
}

// QueryRestApi provides a mock function with given fields: baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger
func (_m *UtilsIface) QueryRestApi(baseURL string, path string, preservePathEncoding bool, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, logger *log.CommonLogger) (error, int) {
	ret := _m.Called(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *log.CommonLogger) error); ok {
		r0 = rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger)
	} else {
		r0 = ret.Error(0)
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, []byte, time.Duration, interface{}, *log.CommonLogger) int); ok {
		r1 = rf(baseURL, path, preservePathEncoding, httpCommand, contentType, body, timeout, out, logger)
	} else {
		r1 = ret.Get(1).(int)
	}

	return r0, r1
}

// QueryRestApiWithAuth provides a mock function with given fields: baseURL, path, preservePathEncoding, username, password, certificate, san_in_certificate, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger
func (_m *UtilsIface) QueryRestApiWithAuth(baseURL string, path string, preservePathEncoding bool, username string, password string, certificate []byte, san_in_certificate bool, httpCommand string, contentType string, body []byte, timeout time.Duration, out interface{}, client *http.Client, keep_client_alive bool, logger *log.CommonLogger) (error, int) {
	ret := _m.Called(baseURL, path, preservePathEncoding, username, password, certificate, san_in_certificate, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, bool, string, string, []byte, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger) error); ok {
		r0 = rf(baseURL, path, preservePathEncoding, username, password, certificate, san_in_certificate, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger)
	} else {
		r0 = ret.Error(0)
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(string, string, bool, string, string, []byte, bool, string, string, []byte, time.Duration, interface{}, *http.Client, bool, *log.CommonLogger) int); ok {
		r1 = rf(baseURL, path, preservePathEncoding, username, password, certificate, san_in_certificate, httpCommand, contentType, body, timeout, out, client, keep_client_alive, logger)
	} else {
		r1 = ret.Get(1).(int)
	}

	return r0, r1
}

// RecoverPanic provides a mock function with given fields: err
func (_m *UtilsIface) RecoverPanic(err *error) {
	_m.Called(err)
}

// RegexpMatch provides a mock function with given fields: regExp, key
func (_m *UtilsIface) RegexpMatch(regExp *regexp.Regexp, key []byte) bool {
	ret := _m.Called(regExp, key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*regexp.Regexp, []byte) bool); ok {
		r0 = rf(regExp, key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// RemovePrefix provides a mock function with given fields: prefix, str
func (_m *UtilsIface) RemovePrefix(prefix string, str string) string {
	ret := _m.Called(prefix, str)

	var r0 string
	if rf, ok := ret.Get(0).(func(string, string) string); ok {
		r0 = rf(prefix, str)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ReplicationStatusNotFoundError provides a mock function with given fields: topic
func (_m *UtilsIface) ReplicationStatusNotFoundError(topic string) error {
	ret := _m.Called(topic)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(topic)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SendHELO provides a mock function with given fields: client, userAgent, readTimeout, writeTimeout, logger
func (_m *UtilsIface) SendHELO(client memcached.ClientIface, userAgent string, readTimeout time.Duration, writeTimeout time.Duration, logger *log.CommonLogger) error {
	ret := _m.Called(client, userAgent, readTimeout, writeTimeout, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(memcached.ClientIface, string, time.Duration, time.Duration, *log.CommonLogger) error); ok {
		r0 = rf(client, userAgent, readTimeout, writeTimeout, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SendHELOWithXattrFeature provides a mock function with given fields: client, userAgent, readTimeout, writeTimeout, logger
func (_m *UtilsIface) SendHELOWithXattrFeature(client memcached.ClientIface, userAgent string, readTimeout time.Duration, writeTimeout time.Duration, logger *log.CommonLogger) (bool, error) {
	ret := _m.Called(client, userAgent, readTimeout, writeTimeout, logger)

	var r0 bool
	if rf, ok := ret.Get(0).(func(memcached.ClientIface, string, time.Duration, time.Duration, *log.CommonLogger) bool); ok {
		r0 = rf(client, userAgent, readTimeout, writeTimeout, logger)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(memcached.ClientIface, string, time.Duration, time.Duration, *log.CommonLogger) error); ok {
		r1 = rf(client, userAgent, readTimeout, writeTimeout, logger)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UnwrapError provides a mock function with given fields: infos
func (_m *UtilsIface) UnwrapError(infos map[string]interface{}) error {
	ret := _m.Called(infos)

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) error); ok {
		r0 = rf(infos)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UrlForLog provides a mock function with given fields: urlStr
func (_m *UtilsIface) UrlForLog(urlStr string) string {
	ret := _m.Called(urlStr)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(urlStr)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ValidateSettings provides a mock function with given fields: defs, settings, logger
func (_m *UtilsIface) ValidateSettings(defs base.SettingDefinitions, settings map[string]interface{}, logger *log.CommonLogger) error {
	ret := _m.Called(defs, settings, logger)

	var r0 error
	if rf, ok := ret.Get(0).(func(base.SettingDefinitions, map[string]interface{}, *log.CommonLogger) error); ok {
		r0 = rf(defs, settings, logger)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
