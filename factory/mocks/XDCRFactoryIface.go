package mocks

import (
	common "github.com/couchbase/goxdcr/common"

	metadata "github.com/couchbase/goxdcr/metadata"

	mock "github.com/stretchr/testify/mock"
)

// XDCRFactoryIface is an autogenerated mock type for the XDCRFactoryIface type
type XDCRFactoryIface struct {
	mock.Mock
}

// CheckpointBeforeStop provides a mock function with given fields: pipeline
func (_m *XDCRFactoryIface) CheckpointBeforeStop(pipeline common.Pipeline) error {
	ret := _m.Called(pipeline)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Pipeline) error); ok {
		r0 = rf(pipeline)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ConstructSSLPortMap provides a mock function with given fields: targetClusterRef, spec
func (_m *XDCRFactoryIface) ConstructSSLPortMap(targetClusterRef *metadata.RemoteClusterReference, spec *metadata.ReplicationSpecification) (map[string]uint16, bool, error) {
	ret := _m.Called(targetClusterRef, spec)

	var r0 map[string]uint16
	if rf, ok := ret.Get(0).(func(*metadata.RemoteClusterReference, *metadata.ReplicationSpecification) map[string]uint16); ok {
		r0 = rf(targetClusterRef, spec)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]uint16)
		}
	}

	var r1 bool
	if rf, ok := ret.Get(1).(func(*metadata.RemoteClusterReference, *metadata.ReplicationSpecification) bool); ok {
		r1 = rf(targetClusterRef, spec)
	} else {
		r1 = ret.Get(1).(bool)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(*metadata.RemoteClusterReference, *metadata.ReplicationSpecification) error); ok {
		r2 = rf(targetClusterRef, spec)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// ConstructSettingsForConnector provides a mock function with given fields: pipeline, connector, settings
func (_m *XDCRFactoryIface) ConstructSettingsForConnector(pipeline common.Pipeline, connector common.Connector, settings metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error) {
	ret := _m.Called(pipeline, connector, settings)

	var r0 metadata.ReplicationSettingsMap
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.Connector, metadata.ReplicationSettingsMap) metadata.ReplicationSettingsMap); ok {
		r0 = rf(pipeline, connector, settings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metadata.ReplicationSettingsMap)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Pipeline, common.Connector, metadata.ReplicationSettingsMap) error); ok {
		r1 = rf(pipeline, connector, settings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConstructSettingsForPart provides a mock function with given fields: pipeline, part, settings, targetClusterRef, ssl_port_map, isSSLOverMem
func (_m *XDCRFactoryIface) ConstructSettingsForPart(pipeline common.Pipeline, part common.Part, settings metadata.ReplicationSettingsMap, targetClusterRef *metadata.RemoteClusterReference, ssl_port_map map[string]uint16, isSSLOverMem bool) (metadata.ReplicationSettingsMap, error) {
	ret := _m.Called(pipeline, part, settings, targetClusterRef, ssl_port_map, isSSLOverMem)

	var r0 metadata.ReplicationSettingsMap
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.Part, metadata.ReplicationSettingsMap, *metadata.RemoteClusterReference, map[string]uint16, bool) metadata.ReplicationSettingsMap); ok {
		r0 = rf(pipeline, part, settings, targetClusterRef, ssl_port_map, isSSLOverMem)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metadata.ReplicationSettingsMap)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Pipeline, common.Part, metadata.ReplicationSettingsMap, *metadata.RemoteClusterReference, map[string]uint16, bool) error); ok {
		r1 = rf(pipeline, part, settings, targetClusterRef, ssl_port_map, isSSLOverMem)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConstructUpdateSettingsForConnector provides a mock function with given fields: pipeline, connector, settings
func (_m *XDCRFactoryIface) ConstructUpdateSettingsForConnector(pipeline common.Pipeline, connector common.Connector, settings metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error) {
	ret := _m.Called(pipeline, connector, settings)

	var r0 metadata.ReplicationSettingsMap
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.Connector, metadata.ReplicationSettingsMap) metadata.ReplicationSettingsMap); ok {
		r0 = rf(pipeline, connector, settings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metadata.ReplicationSettingsMap)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Pipeline, common.Connector, metadata.ReplicationSettingsMap) error); ok {
		r1 = rf(pipeline, connector, settings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConstructUpdateSettingsForPart provides a mock function with given fields: pipeline, part, settings
func (_m *XDCRFactoryIface) ConstructUpdateSettingsForPart(pipeline common.Pipeline, part common.Part, settings metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error) {
	ret := _m.Called(pipeline, part, settings)

	var r0 metadata.ReplicationSettingsMap
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.Part, metadata.ReplicationSettingsMap) metadata.ReplicationSettingsMap); ok {
		r0 = rf(pipeline, part, settings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metadata.ReplicationSettingsMap)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Pipeline, common.Part, metadata.ReplicationSettingsMap) error); ok {
		r1 = rf(pipeline, part, settings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConstructUpdateSettingsForService provides a mock function with given fields: pipeline, service, settings
func (_m *XDCRFactoryIface) ConstructUpdateSettingsForService(pipeline common.Pipeline, service common.PipelineService, settings metadata.ReplicationSettingsMap) (metadata.ReplicationSettingsMap, error) {
	ret := _m.Called(pipeline, service, settings)

	var r0 metadata.ReplicationSettingsMap
	if rf, ok := ret.Get(0).(func(common.Pipeline, common.PipelineService, metadata.ReplicationSettingsMap) metadata.ReplicationSettingsMap); ok {
		r0 = rf(pipeline, service, settings)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(metadata.ReplicationSettingsMap)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(common.Pipeline, common.PipelineService, metadata.ReplicationSettingsMap) error); ok {
		r1 = rf(pipeline, service, settings)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewPipeline provides a mock function with given fields: topic, progressRecorder
func (_m *XDCRFactoryIface) NewPipeline(topic string, progressRecorder common.PipelineProgressRecorder) (common.Pipeline, error) {
	ret := _m.Called(topic, progressRecorder)

	var r0 common.Pipeline
	if rf, ok := ret.Get(0).(func(string, common.PipelineProgressRecorder) common.Pipeline); ok {
		r0 = rf(topic, progressRecorder)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Pipeline)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, common.PipelineProgressRecorder) error); ok {
		r1 = rf(topic, progressRecorder)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewSecondaryPipeline provides a mock function with given fields: topic, primaryPipeline, progress_recorder, pipelineType
func (_m *XDCRFactoryIface) NewSecondaryPipeline(topic string, primaryPipeline common.Pipeline, progress_recorder common.PipelineProgressRecorder, pipelineType common.PipelineType) (common.Pipeline, error) {
	ret := _m.Called(topic, primaryPipeline, progress_recorder, pipelineType)

	var r0 common.Pipeline
	if rf, ok := ret.Get(0).(func(string, common.Pipeline, common.PipelineProgressRecorder, common.PipelineType) common.Pipeline); ok {
		r0 = rf(topic, primaryPipeline, progress_recorder, pipelineType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Pipeline)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, common.Pipeline, common.PipelineProgressRecorder, common.PipelineType) error); ok {
		r1 = rf(topic, primaryPipeline, progress_recorder, pipelineType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetStartSeqno provides a mock function with given fields: pipeline
func (_m *XDCRFactoryIface) SetStartSeqno(pipeline common.Pipeline) error {
	ret := _m.Called(pipeline)

	var r0 error
	if rf, ok := ret.Get(0).(func(common.Pipeline) error); ok {
		r0 = rf(pipeline)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}
