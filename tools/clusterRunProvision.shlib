#!/usr/bin/env bash
set -u

# Copyright (c) 2019 Couchbase, Inc.
# Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file
# except in compliance with the License. You may obtain a copy of the License at
#   http://www.apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software distributed under the
# License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
# either express or implied. See the License for the specific language governing permissions
# and limitations under the License.

# BASH VERSION CHECK - since hash maps are implemented >= bash version 4
bash_major_version=`echo ${BASH_VERSION}|cut -d. -f1`
if (( $bash_major_version < 4 ));then
	echo "===================================================================="
	echo "Bash version >= 4 is required. Current bash version: ${BASH_VERSION}. Script may fail"
	echo "How to upgrade bash on MacOS:"
	echo "1. Run \"brew update && brew install bash\" to install the latest version of bash for macOS"
	echo "2. Run \"sudo vim /etc/shells\" and add \"/usr/local/bin/bash\" to the list"
	echo "3. Run \"chsh -s /usr/local/bin/bash\" to set default shell to the new one"
	echo "4. Exit and restart the current session"
	echo "===================================================================="
	return 1
fi

. ./importExporter.shlib

# globals
# -----------------
declare DEFAULT_ADMIN
declare DEFAULT_PW
# Run curl in silent mode to prevent progress bar
CURL="curl -s"
POOLS_DEFAULT_BUCKETS_PATH="pools/default/buckets"
CBWORKLOAD_COLLECTION_NUM_ITEMS=10000


# topological globals
# -----------------
# cluster -> Bucket(s)
# Bucket -> Scopes
# Scopes -> Collections
declare -A CLUSTER_NAME_PORT_MAP
declare -A CLUSTER_NAME_XDCR_PORT_MAP
declare -A CLUSTER_NAME_BUCKET_MAP
declare -A BUCKET_NAME_RAMQUOTA_MAP
declare -A BUCKET_NAME_SCOPE_MAP
declare -A SCOPE_NAME_COLLECTION_MAP
declare -A BUCKET_PROPERTIES_OUTPUT_MAP
declare -A BUCKET_REPL_PROPERTIES_MAP
declare -A BUCKET_REPL_PROPERTIES_OUTPUT_MAP
declare -A BUCKET_REPL_EXPORT_MAP

# optional globals
# -----------------
# if not defined, will look for it using locate
declare CBWORKLOADGEN=""
# Key is in the format of "BucketName,ParameterName"
# Value is in the format of actual value to send
declare -A BUCKET_NAME_PROPERTIES_MAP

# These are to record which containers have been created already
# to prevent duplicated creates
declare -A CLUSTER_NAME_BUCKET_DONE_MAP
declare -A BUCKET_NAME_SCOPE_DONE_MAP
declare -A SCOPE_NAME_COLLECTION_DONE_MAP

# Input
# 0: ClusterName
# 1: Bucket Name
# 2: Scope Name (optional)
# 3: Collection Name (optional)
# Return code:
# 0: if namespace exists
# 1: If it does not
function checkNamespaceCreated {
	local clusterName=$1
	local bucketName=$2
	local scopeName=${3:-}
	local collectionName=${4:-}
	local key
	local key2

	for chkClusterName in `echo ${!CLUSTER_NAME_BUCKET_DONE_MAP[@]}`
	do
		if [[ "$chkClusterName" == "$clusterName" ]];then
			bucketNames=(${CLUSTER_NAME_BUCKET_DONE_MAP[$clusterName]:-})
			for chkBucketName in `echo ${bucketNames[@]}`
			do
				if [[ "$chkBucketName" == "$bucketName" ]];then
					if [[ -z "${scopeName:-}" ]];then
						# User asked for clusterName:bucketName and it was done
						return 0
					fi
					key="${chkClusterName},${chkBucketName}"
					for chkScopeName in `echo ${BUCKET_NAME_SCOPE_DONE_MAP["$key"]:-}`
					do
						if [[ "$chkScopeName" == "$scopeName" ]];then
							if [[ -z "${collectionName:-}" ]];then
								#User asked for cluster:bucket:scope and it's done
								return 0
							fi
							key2="${chkClusterName},${chkBucketName},${chkScopeName}"
							for chkColName in `echo ${SCOPE_NAME_COLLECTION_DONE_MAP["$key2"]:-}`
							do
								if [[ "$chkColName" == "$collectionName" ]];then
									return 0
								fi
							done
						fi
					done
				fi
			done
		fi
	done
	return 1
}

function recordNamespaceCreated {
	local clusterName=$1
	local bucketName=$2
	local scopeName=${3:-}
	local collectionName=${4:-}

	if [[ -z "${scopeName:-}" ]];then
		# bucket
		local -a bucketArr
		local key="${clusterName}"
		if [[ -z ${CLUSTER_NAME_BUCKET_DONE_MAP[$key]:-} ]];then
			bucketArr=("$bucketName")
		else
			bucketArr=(${CLUSTER_NAME_BUCKET_DONE_MAP[$key]})
			bucketArr[${#bucketArr[@]}]="$bucketName"
		fi
		CLUSTER_NAME_BUCKET_DONE_MAP[$key]=${bucketArr[@]}
	elif [[ -z "${collectionName:-}" ]];then
		local -a scopeArr
		local key="${clusterName},${bucketName}"
		if [[ -z ${BUCKET_NAME_SCOPE_DONE_MAP[$key]:-} ]];then
			scopeArr=("$scopeName")
		else
			scopeArr=(${BUCKET_NAME_SCOPE_DONE_MAP[$key]})
			scopeArr[${#scopeArr[@]}]="$scopeName"
		fi
		BUCKET_NAME_SCOPE_DONE_MAP[$key]=${scopeArr[@]}
	else
		local -a colArr
		local key="${clusterName},${bucketName},${scopeName}"
		if [[ -z ${SCOPE_NAME_COLLECTION_DONE_MAP[$key]:-} ]];then
			colArr=("$collectionName")
		else
			colArr=(${SCOPE_NAME_COLLECTION_DONE_MAP[$key]})
			colArr[${#colArr[@]}]="$collectionName"
		fi
		SCOPE_NAME_COLLECTION_DONE_MAP[$key]=${colArr[@]}
	fi
}

# Input:
# 1. Bucket name
# 2. An associative array of Key - Parameter Value - value to send
# Will store information as:
# BUCKET_NAME_PROPERTIES_MAP=([B1,CompressionMode]="Active" [B1,ramQuotaMB]="100" )
function insertPropertyIntoBucketNamePropertyMap {
	local bucketName=$1
	local -n incomingMap=$2
	for key in ${!incomingMap[@]}
	do
		BUCKET_NAME_PROPERTIES_MAP[${bucketName},${key}]=${incomingMap[$key]}
	done
	export BUCKET_NAME_PROPERTIES_MAP
}

function cleanupBucketNamePropertyMap {
	BUCKET_NAME_PROPERTIES_MAP=()
}

# Input:
# 1. Bucket name
# Outputs associative array as a exported global of BUCKET_PROPERTIES_OUTPUT_MAP
function getPropertiesFromBucketNamePropertyMap {
	local bucketName=$1

	# first clear previous data - cannot use unset as it breaks the return val
	BUCKET_PROPERTIES_OUTPUT_MAP=()

	# key is bucketName,Property
	for bp in ${!BUCKET_NAME_PROPERTIES_MAP[@]}
	do
		key=`echo "$bp" | cut -d, -f1`
		property=`echo "$bp" | cut -d, -f2`
		if [[ $key != $bucketName ]];then
			continue
		fi
		BUCKET_PROPERTIES_OUTPUT_MAP["$property"]=${BUCKET_NAME_PROPERTIES_MAP[$bp]}
	done
	export BUCKET_PROPERTIES_OUTPUT_MAP
}

# Input:
# 1. Source Cluster name
# 2. Source Bucket name
# 3. Target Cluster name
# 4. Target Cluster name
# 2. An associative array of Key - Parameter Value - value to send
function insertPropertyIntoBucketReplPropertyMap {
	local sourceCluster=$1
	local sourceBucket=$2
	local targetCluster=$3
	local targetBucket=$4
	local -n incomingMap=$5

	for key in ${!incomingMap[@]}
	do
		BUCKET_REPL_PROPERTIES_MAP[${sourceCluster},${sourceBucket},${targetCluster},${targetBucket},${key}]=${incomingMap[$key]}
	done
	export BUCKET_REPL_PROPERTIES_MAP
}

# Input:
# 1. Source Cluster name
# 2. Source Bucket name
# 3. Target Cluster name
# 4. Target Cluster name
# 2. An associative array of Key - Parameter Value - value to send
function insertBucketReplIntoExportMap {
	local sourceCluster=$1
	local sourceBucket=$2
	local targetCluster=$3
	local targetBucket=$4
	local replRestID=$5

	BUCKET_REPL_EXPORT_MAP[${sourceCluster},${sourceBucket},${targetCluster},${targetBucket}]=${replRestID}
	export BUCKET_REPL_EXPORT_MAP
}

function getBucketReplicationRestID {
	local chkSourceCluster=$1
	local chkSourceBucket=$2
	local chkTargetCluster=$3
	local chkTargetBucket=$4

	for replKey in "${!BUCKET_REPL_EXPORT_MAP[@]}"
	do
		local sourceCluster=`echo "$replKey" | cut -d, -f1`
		local restID=`echo "${BUCKET_REPL_EXPORT_MAP[$replKey]}" | sed 's/"//g'`
		local sourceBucket=`echo "$replKey" | cut -d, -f2`
		local targetCluster=`echo "$replKey" | cut -d, -f3`
		local targetBucket=`echo "$replKey" | cut -d, -f4`

		if [[ "$chkSourceCluster" == "$sourceCluster" && "$chkSourceBucket" == "$sourceBucket" && "$chkTargetCluster" == "$targetCluster" && "$chkTargetBucket" == "$targetBucket" ]];then
			echo "$restID"
			return 0
		fi
	done
	return 1
}

# Input:
# 1. Source Cluster name
# 2. Source Bucket name
# 3. Target Cluster name
# 4. Target Cluster name
function getPropertiesFromBucketReplPropertyMap {
	local sourceCluster=$1
	local sourceBucket=$2
	local targetCluster=$3
	local targetBucket=$4
	
	local checkString="${sourceCluster},${sourceBucket},${targetCluster},${targetBucket}"
	# key is bucketName,Property
	for bp in ${!BUCKET_REPL_PROPERTIES_MAP[@]}
	do
		key=`echo "$bp" | cut -d, -f1-4`
		property=`echo "$bp" | cut -d, -f5`
		if [[ $key != $checkString ]];then
			continue
		fi
		BUCKET_REPL_PROPERTIES_OUTPUT_MAP["$property"]=${BUCKET_REPL_PROPERTIES_MAP[$bp]}
	done
}



function printBucketPropertiesResults {
	declare -p BUCKET_PROPERTIES_OUTPUT_MAP | cut -d' ' -f3- | cut -d'=' -f2-
}

function printBucketReplPropertiesResults {
	declare -p BUCKET_REPL_PROPERTIES_OUTPUT_MAP | cut -d' ' -f3- | cut -d= -f2-
}

declare -a getBucketOutArr
function getBucketPropertiesRESTString {
	getBucketOutArr=()
	for property in "${!BUCKET_PROPERTIES_OUTPUT_MAP[@]}"
	do
		getBucketOutArr+=("-d")
		getBucketOutArr+=("${property}=${BUCKET_PROPERTIES_OUTPUT_MAP[$property]}")
	done
}

declare -a getBucketReplOutArr
function getBucketReplPropertiesRESTString {
	getBucketReplOutArr=()
	for property in "${!BUCKET_REPL_PROPERTIES_OUTPUT_MAP[@]}"
	do
		getBucketReplOutArr+=("-d")
		getBucketReplOutArr+=("${property}=${BUCKET_REPL_PROPERTIES_OUTPUT_MAP[$property]}")
	done
}

function getBucketInfoRaw {
	local clusterName=$1
	local bucketName=$2
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X GET http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName
}

function getBucketInfo {
	local clusterName=$1
	local bucketName=$2

	if (( `checkJQ` != 0 ));then
		getBucketInfoRaw $clusterName $bucketName
	else
		echo `getBucketInfoRaw $clusterName $bucketName` | jq
	fi
}

function getBucketItemCount {
	local clusterName=$1
	local bucketName=$2
	local maxRetry=3
	local i

	if (( `checkJQ` != 0 ));then
		echo "Cannot run $0 without jq"
		return 1
	fi

	for (( i=0; $i < $maxRetry; i=$(($i+1)) ))
	do
		rawOutput=`getBucketInfoRaw $clusterName $bucketName`
		if (( $? != 0 ));then
			continue
		fi
		basicStats=`echo "$rawOutput" | jq '.basicStats'`
		if (( $? != 0 ));then
			continue
		fi
		itemCount=`echo "$basicStats" | jq '.itemCount'`
		if (( $? == 0 ));then
			echo "$itemCount"
			break
		fi
	done
}

# Tests and see if "cluster_run -n x" has been run
function testForClusterRun {
	for port in ${CLUSTER_NAME_PORT_MAP[@]}
		do
		$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X GET http://localhost:$port/nodes/self/controller/settings > /dev/null 2>&1
		if (( $? != 0 ));then
			echo "Node $port not found. Skipping cluster_run XDCR init"
			return 1
		fi
	done
}

function setupCluster {
	for clusterName in `echo ${!CLUSTER_NAME_PORT_MAP[@]}`
	do
		local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}
		echo "SETTING up cluster name $clusterName on port $port"
		$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X POST http://localhost:$port/nodes/self/controller/settings > /dev/null 2>&1
		$CURL -X POST http://localhost:$port/node/controller/rename -d hostname=127.0.0.1 > /dev/null 2>&1
		$CURL -X POST http://localhost:$port/node/controller/setupServices -d services=kv > /dev/null 2>&1
		$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -v -X POST http://localhost:$port/settings/web -d password=$DEFAULT_PW -d username=$DEFAULT_ADMIN -d port=$port > /dev/null 2>&1
		if (( $? != 0 ));then
			return $?
		fi
		echo ""
	done
}

function enableDeveloperPreview {
	for clusterName in `echo ${!CLUSTER_NAME_PORT_MAP[@]}`
	do
 		# enable developer preview
		echo -n "Enabling developer preview on $clusterName"
		local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}
		$CURL -X POST -u $DEFAULT_ADMIN:$DEFAULT_PW http://localhost:$port/settings/developerPreview -d enabled="true"
		if (( $? != 0 ));then
			return $?
		fi
		echo ""
	done
}

function setupBuckets {
	for clusterName in `echo ${!CLUSTER_NAME_BUCKET_MAP[@]}`
	do
		local bucketNames=(${CLUSTER_NAME_BUCKET_MAP[$clusterName]:-})
		local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}
		for bucketName in `echo ${bucketNames[@]}`
		do
			getPropertiesFromBucketNamePropertyMap "$bucketName"
			echo "For cluster $clusterName CREATING bucket $bucketName with properties `printBucketPropertiesResults`"
			local ramQuotaCheck=${BUCKET_PROPERTIES_OUTPUT_MAP["ramQuotaMB"]:-}
			if [[ -z "$ramQuotaCheck" ]];then
				echo "Missing ramQuota for $bucketName"
				return 1
			fi
			getBucketPropertiesRESTString

			# Only run the bucket create command if it hasn't been executed before
			checkNamespaceCreated "$clusterName" "$bucketName"
			if (( ! $? == 0 ));then
				$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X POST http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH -d name=$bucketName ${getBucketOutArr[@]}  > /dev/null 2>&1
				if (( $? != 0 ));then
					return $?
				fi
				recordNamespaceCreated "$clusterName" "$bucketName"
			fi

			# If bucket has scopes
			if [[ ! -z "${BUCKET_NAME_SCOPE_MAP[$bucketName]:-}" ]];then
				setupScopes $clusterName $bucketName
			fi
		done
	done
}

function cleanupBuckets {
	for clusterName in `echo ${!CLUSTER_NAME_BUCKET_MAP[@]}`
	do
		local bucketNames=(${CLUSTER_NAME_BUCKET_MAP[$clusterName]:-})
		local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}
		for bucketName in `echo ${bucketNames[@]}`
		do
		echo "For cluster $clusterName DELETING bucket $bucketName"
		$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X DELETE http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName > /dev/null 2>&1
		done
	done
	CLUSTER_NAME_BUCKET_DONE_MAP=()
	BUCKET_NAME_SCOPE_DONE_MAP=()
	SCOPE_NAME_COLLECTION_DONE_MAP=()
}

function createScope {
	local clusterName=$1
	local bucketName=$2
	local scopeName=$3
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	echo "For cluster $clusterName bucket $bucketName CREATING scope $scopeName"
	$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X POST http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName/collections -d name=$scopeName > /dev/null 2>&1
}

function deleteScope {
	local clusterName=$1
	local bucketName=$2
	local scopeName=$3
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	echo "For cluster $clusterName bucket $bucketName DELETING scope $scopeName"
	$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X DELETE http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName/collections/$scopeName/ > /dev/null 2>&1
}

# inputs
# 1. cluster name
# 2. bucket name
function setupScopes {
	local clusterName=$1
	local bucketName=$2
	if [[ -z "${clusterName:-}" ]] || [[ -z "${bucketName:-}" ]];then
		echo "Invalid input"
		return 1
	fi

	local -a scopesArr=(${BUCKET_NAME_SCOPE_MAP[$bucketName]:-})
	if [[ -z "${scopesArr:-}" ]];then
		echo "No scopes found for bucket $bucketName"
		return 1
	fi

	for scopeName in `echo ${scopesArr[@]}`
	do
		checkNamespaceCreated "$clusterName" "$bucketName" "$scopeName"
		if (( ! $? == 0 ));then
			createScope "$clusterName" "$bucketName" "$scopeName"
			recordNamespaceCreated "$clusterName" "$bucketName" "$scopeName"
		fi
		# If scope has collections
		if [[ ! -z "${SCOPE_NAME_COLLECTION_MAP[$scopeName]:-}" ]];then
			setupCollections $clusterName $bucketName $scopeName
		fi
	done
}

function createCollection {
	local clusterName=$1
	local bucketName=$2
	local scopeName=$3
	local collectionName=$4
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	echo "For cluster $clusterName bucket $bucketName scope $scopeName CREATING collection $collectionName"
	$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X POST http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName/collections/$scopeName -d name=$collectionName > /dev/null 2>&1
}

function deleteCollection {
	local clusterName=$1
	local bucketName=$2
	local scopeName=$3
	local collectionName=$4
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	echo "For cluster $clusterName bucket $bucketName scope $scopeName DELETING collection $collectionName"
	$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X DELETE http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName/collections/$scopeName/$collectionName > /dev/null 2>&1
}

# inputs
# 1. cluster name
# 2. bucket name
# 3. scope name
function setupCollections {
	local clusterName=$1
	local bucketName=$2
	local scopeName=$3
	if [[ -z "${clusterName:-}" ]] || [[ -z "${bucketName:-}" ]] || [[ -z "${scopeName:-}" ]];then
		echo "Invalid input"
		return 1
	fi

	local collectionsArr=(${SCOPE_NAME_COLLECTION_MAP[$scopeName]:-})
	if [[ -z "${collectionsArr:-}" ]];then
		echo "No collections found for scope $scopeName"
		return 1
	fi

	for collectionName in `echo ${collectionsArr[@]}`
	do
		checkNamespaceCreated "$clusterName" "$bucketName" "$scopeName" "$collectionName"
		if (( ! $? == 0 ));then
			createCollection "$clusterName" "$bucketName" "$scopeName" "$collectionName"
			recordNamespaceCreated "$clusterName" "$bucketName" "$scopeName" "$collectionName"
		fi
	done
}

# Allow specific flags to be passed in:
# -d : <developer mode>
function setupTopologies {
  local OPTIND
  local d
  local developerPreviewSet=0
  local opt

  while getopts "d" opt;do
    case ${opt} in
      d)
       developerPreviewSet=1
      ;;
    esac
  done

	setupCluster
	if (( $? != 0 ));then
		return $?
	fi

	if (( $developerPreviewSet == 1 ));then
	  enableDeveloperPreview
	  if (( $? != 0 ));then
	    return $?
	  fi
	fi

	setupBuckets
	if (( $? != 0 ));then
		return $?
	fi
}

# Takes 2 arguments:
# 1- Source cluster name
# 2- Target cluster name
function createRemoteClusterReference {
	local source=$1
	local target=$2
	if [[ -z "${source:-}" ]] || [[ -z "${target:-}" ]];then
		echo "Invalid input"
		return 1
	fi
	local sourcePort=${CLUSTER_NAME_PORT_MAP[$source]:-}
	local targetPort=${CLUSTER_NAME_PORT_MAP[$target]:-}

	echo "Creating remote cluster reference from $source to $target"
	$CURL -X POST -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:$sourcePort/pools/default/remoteClusters -d name=$target -d hostname=127.0.0.1:$targetPort -d username=$DEFAULT_ADMIN -d password=$DEFAULT_PW
	echo ""
}

function createReplicationInternal {
	local sourceID=$1
	local targetID=$2
	local i

	# Under stressed systems, possible that replication creation could fail
	for (( i=0; $i < 3; i=$(($i+1)) ))
	do
		replicationID=`$CURL -X POST -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:${NODEPORTS[$sourceID]}/controller/createReplication -d fromBucket=${BUCKETNAMES[$sourceID]} -d toCluster=${CLUSTERNAMES[$targetID]} -d toBucket=${BUCKETNAMES[$targetID]} -d replicationType=continuous -d checkpointInterval=60 -d statsInterval=500`
		if (( $? == 0 ));then
			echo "$replicationID"
		elif (( $i != 2 ));then
			echo "Replication creation returned error code. Will retry in 10 seconds..."
			sleep 10
		fi
	done
}

# Check if jq is present. It is used for parsing JSON in a bash environment
function checkJQ {
	which jq > /dev/null 2>&1
	if (( $? != 0 ));then
		which brew > /dev/null 2>&1
		if (( $? != 0 ));then
			return $?
		fi
		echo "jq not found... installing from homebrew"
		brew install jq
		return $?
	fi
	echo $?
}

function getKeyUsingJQ {
	local arg=$1
	local key=$2
	if [[ -z "${arg:-}" ]];then
		return 1
	fi

	echo $arg | jq ${key} 2> /dev/null
}

function validateClusterBucket {
	local cluster=$1
	local bucket=$2

	local -a bucketsArr
	bucketsArr=(${CLUSTER_NAME_BUCKET_MAP[$cluster]:-})
	local found="false"
	for checkBucket in `echo ${bucketsArr[@]}`
	do
		if [[ "$bucket" == "$checkBucket" ]];then
			found="true"
			break
		fi
	done
	if [[ "$found" == "false" ]];then
		echo "Bucket $bucket is not defined for cluster $cluster"
		return 1
	fi
	return 0
}

#Input:
# 1 - source cluster
# 2 - source bucketname
# 3 - target cluster
# 4 - target bucketname
# TODO - optional args for replication
function createBucketReplication {
	local sourceCluster=$1
	local sourceBucket=$2
	local targetCluster=$3
	local targetBucket=$4
	local -a replProperties=$5
	local i

	if [[ -z "${sourceCluster:-}" ]] || [[ -z "${sourceBucket:-}" ]] || [[ -z "${targetCluster:-}" ]] || [[ -z "${targetBucket:-}" ]] || [[ -z "${replProperties}" ]];then
		echo "Invalid input"
		return 1
	fi
	# check if bucket belongs to cluster
	validateClusterBucket $sourceCluster $sourceBucket
	if (( $? != 0 ));then
		return $?
	fi
	validateClusterBucket $targetCluster $targetBucket
	if (( $? != 0 ));then
		return $?
	fi
	
	insertPropertyIntoBucketReplPropertyMap $sourceCluster $sourceBucket $targetCluster $targetBucket $replProperties
	getPropertiesFromBucketReplPropertyMap $sourceCluster $sourceBucket $targetCluster $targetBucket

	local sourcePort=${CLUSTER_NAME_PORT_MAP[$sourceCluster]:-}
	getBucketReplPropertiesRESTString

	for (( i=0; $i < 3; i=$(($i+1)) ))
	do
		repId=`$CURL -X POST -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:$sourcePort/controller/createReplication -d fromBucket=$sourceBucket -d toCluster=$targetCluster -d toBucket=$targetBucket "${getBucketReplOutArr[@]}"`
		if (( (( $? == 0 )) && (( `echo "$repId" | grep -c error` == 0 )) ));then
			if (( `checkJQ` == 0 ));then
				repIdReal=`getKeyUsingJQ "$repId" '.id'`
				if [[ "$repIdReal" == "" ]];then
					echo "Captured replicationID: $repId"
				else
					restFriendlyReplID=`echo $repIdReal | sed 's|/|%2F|g'`
					echo "ReplicationID: $repIdReal Rest-FriendlyID: $restFriendlyReplID"
					insertBucketReplIntoExportMap "$sourceCluster" "$sourceBucket" "$targetCluster" "$targetBucket" "$restFriendlyReplID"
				fi
			else
				echo "Captured replicationID: $repId"
			fi
			return 0
		elif (( $i != 2 ));then
			echo "Replication creation returned error code. Will retry in 10 seconds..."
			sleep 10
		fi
	done
}

function cleanupRemoteClusterRefs {
	for replKey in "${!BUCKET_REPL_EXPORT_MAP[@]}"
	do
		local sourceCluster=`echo "$replKey" | cut -d, -f1`
		local sourcePort=${CLUSTER_NAME_PORT_MAP[$sourceCluster]:-}
		local targetCluster=`echo "$replKey" | cut -d, -f3`

		echo "Deleting remote cluster reference $targetCluster on cluster $sourceCluster"
		$CURL -X DELETE -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:$sourcePort/pools/default/remoteClusters/$targetCluster > /dev/null 2>&1
	done
}

function cleanupBucketReplications {
	for replKey in "${!BUCKET_REPL_EXPORT_MAP[@]}"
	do
		local sourceCluster=`echo "$replKey" | cut -d, -f1`
		local restID=`echo "${BUCKET_REPL_EXPORT_MAP[$replKey]}" | sed 's/"//g'`
		local sourcePort=${CLUSTER_NAME_PORT_MAP[$sourceCluster]:-}
		local sourceBucket=`echo "$replKey" | cut -d, -f2`
		local targetCluster=`echo "$replKey" | cut -d, -f3`
		local targetBucket=`echo "$replKey" | cut -d, -f4`

		echo "DELETING replication from sourceCluster $sourceCluster sourceBucket $sourceBucket to targetCluster $targetCluster targetBucket $targetBucket..."
		$CURL -X DELETE -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:$sourcePort/controller/cancelXDCR/${restID} > /dev/null 2>&1
	done
}

function findCbDocLoader {
	if [[ ! -z "${CBDOCLOADER:-}" ]];then
		echo "$CBDOCLOADER"
		return 0
	fi

	which locate > /dev/null 2>&1
	if (( $? != 0 ));then
		return $?
	fi
	# Just pick one
	docloader=`locate cbdocloader | grep install | grep bin | head -n 1`
	if (( $? != 0 ));then
		echo ""
		return 1
	fi
	if [[ -z "${CBDOCLOADER:-}" ]];then
		# set it in case needed it in future
		export CBDOCLOADER=$docloader
	fi
	echo "$docloader"
	return 0

}

#Input
# 1 - cluster name
# 2 - bucket name
# 3 - file name
function runDocLoader {
	local clusterName=$1
	local bucketName=$2
	local fileName=$3
	if [[ -z "${clusterName:-}" ]] || [[ -z "${bucketName:-}" ]] || [[ -z "${fileName:-}" ]];then
		echo "Invalid input"
		return 1
	fi
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}
	
	docLoader=`findCbDocLoader`
	if (( $? != 0 ));then
		echo "Could not find docLoader"
		return 1
	fi
	
	getPropertiesFromBucketNamePropertyMap "$bucketName"
	local ramQuota=${BUCKET_PROPERTIES_OUTPUT_MAP["ramQuotaMB"]:-}
	if [[ -z "$ramQuota" ]];then
		echo "Missing ramQuota for $bucketName"
		return 1
	fi

	Echo "Executing cbdocloader on bucket $bucketName for file $fileName..."
	$docLoader -c localhost:${port} -u $DEFAULT_ADMIN -p $DEFAULT_PW -b $bucketName -m $ramQuota -d $fileName
}

function findCbWorkloadGen {
	if [[ ! -z "${CBWORKLOADGEN:-}" ]];then
		echo "$CBWORKLOADGEN"
		return 0
	fi

	which locate > /dev/null 2>&1
	if (( $? != 0 ));then
		return $?
	fi
	# Just pick one
	workloadGen=`locate cbworkloadgen | grep build\/couchbase-cli | head -n 1`
	if (( $? != 0 ));then
		echo ""
		return 1
	fi
	if [[ -z "$CBWORKLOADGEN" ]];then
		# set it in case needed it in future
		CBWORKLOADGEN=$workloadGen
	fi
	echo "$workloadGen"
	return 0
}

# Input
# 1 - cluster name
# 2 - bucket name
function runCbWorkloadGenBucket {
	local clusterName=$1
	local bucketName=$2
	local i
	if [[ -z "${clusterName:-}" ]] || [[ -z "${bucketName:-}" ]];then
		echo "Invalid input"
		return 1
	fi
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	workloadGen=`findCbWorkloadGen`
	if (( $? != 0 )) || [[ -z "$workloadGen" ]];then
		echo "Could not find workload generator binary"
		return 1
	fi

	for (( i=0; i < 3; i=$(( $i+1 ))))
	do
		echo "Running cbworkloadGen on $clusterName bucket $bucketName"
		# Run 10000 items of json documents with set/get ratio of 100%
		$workloadGen -i 10000 -j -r 1 -n 127.0.0.1:$port -b $bucketName -u $DEFAULT_ADMIN -p $DEFAULT_PW --prefix=xdcrProv_$clusterName
		if (( $? == 0 ));then
			return 0
		elif (( $? != 0 )) && (( $i != 2 ));then
			echo "Workloadgen resulted in error. Possibly system is loaded. Retry in 10 seconds"
			sleep 10
		fi
	done
}

# Very basic way of validation - given a target cluster, simply write the same docs naming convention as the target document
# If the doc count hasn't increased, then the keys are replicated correctly
function validateCbWorkloadGenCollection {
	local validateCluster=$1
	local validateBucket=$2
	local validateScope=$3
	local validateCollection=$4

	local clusterName=$5
	local bucketName=$6
	local scopeName=$7
	local collectionName=$8
	local additionalPrefix${9:-}

	if [[ -z "${clusterName:-}" ]] || [[ -z "${bucketName:-}" ]] || [[ -z "${scopeName:-}" ]] || [[ -z "${collectionName:-}" ]] || \
		[[ -z "${validateCluster:-}" ]] || [[ -z "${validateBucket:-}" ]] || [[ -z "${validateScope:-}" ]] || [[ -z "${validateCollection:-}" ]];then
		echo "Invalid input"
		return 1
	fi

	local port=${CLUSTER_NAME_PORT_MAP[$validateCluster]:-}
	workloadGen=`findCbWorkloadGen`
	if (( $? != 0 )) || [[ -z "$workloadGen" ]];then
		echo "Could not find workload generator binary"
		return 1
	fi

	manifestOutput=`getManifest $validateCluster $validateBucket`
	if (( $? != 0 ));then
		echo "Error retrieving manifest for cluster $validateCluster bucket $validateBucket"
		return 1
	fi

	collectionId=`getCollectionIdFromScopeAndCollectionName "$manifestOutput" "$validateScope" "$validateCollection"`
	if (( $? != 0 ));then
		echo "Error retrieving collection ID for scope $validateScope collection $validateCollection"
		echo "Output: $manifestOutput"
		return 1
	fi

	local prefix
	local colIdHex
	for (( i=0; i < 3; i=$(( $i+1 ))))
	do
		echo "Validating on $validateCluster $validateBucket $validateScope $validateCollection by running same name as it was on $clusterName"
		prefix=xdcrProv_$clusterName
		if [[ ! -z "${additionalPrefix:-}" ]];then
			prefix=${prefix}_${additionalPrefix}
		fi
		# Run 10000 items of json documents with set/get ratio of 100%
		echo "Running cbworkloadGen on port $port bucket $validateBucket collectionId $collectionId"
		colIdHex=`printf '%x' $collectionId`
		$workloadGen -i $CBWORKLOAD_COLLECTION_NUM_ITEMS  -j -r 1 -n 127.0.0.1:$port -b $validateBucket -u $DEFAULT_ADMIN -p $DEFAULT_PW --prefix=$prefix -c $colIdHex
		if (( $? == 0 ));then
			return 0
		elif (( $? != 0 )) && (( $i != 2 ));then
			echo "Workloadgen resulted in error. Possibly system is loaded. Retry in 10 seconds"
			sleep 10
		fi
	done
}

CONTINUOUS_WORKLOAD_PREFIX="_xdcr_continuous_workload"

function runCbWorkloadGenCollection {
	local clusterName=$1
	local bucketName=$2
	local scopeName=$3
	local collectionName=$4
	local additionalPrefix=${5:-}
	local collectionId
	local i
	local loopFlag=""

	if [[ -z "${clusterName:-}" ]] || [[ -z "${bucketName:-}" ]] || [[ -z "${scopeName:-}" ]] || [[ -z "${collectionName:-}" ]];then
		echo "Invalid input"
		return 1
	fi
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	workloadGen=`findCbWorkloadGen`
	if (( $? != 0 )) || [[ -z "$workloadGen" ]];then
		echo "Could not find workload generator binary"
		return 1
	fi

	manifestOutput=`getManifest $clusterName $bucketName`
	if (( $? != 0 ));then
		echo "Error retrieving manifest for cluster $clusterName bucket $bucketName"
		return 1
	fi

	collectionId=`getCollectionIdFromScopeAndCollectionName "$manifestOutput" "$scopeName" "$collectionName"`
	if (( $? != 0 ));then
		echo "Error retrieving collection ID for scope $scopeName collection $collectionName"
		echo "Output: $manifestOutput"
		return 1
	fi

	local prefix
	for (( i=0; i < 3; i=$(( $i+1 ))))
	do
		echo "Running cbworkloadGen on $clusterName bucket $bucketName scope: $scopeName collection $collectionName (ID: $collectionId)"
		prefix=xdcrProv_$clusterName
		if [[ ! -z "$additionalPrefix" ]];then
			prefix=${prefix}_${additionalPrefix}
			if [[ "$additionalPrefix" == "$CONTINUOUS_WORKLOAD_PREFIX" ]];then
				echo "LOOPFLAG"
				loopFlag="-l"
			fi
		fi
		# Run 10000 items of json documents with set/get ratio of 100%
		$workloadGen -i $CBWORKLOAD_COLLECTION_NUM_ITEMS  -j -r 1 -n 127.0.0.1:$port -b $bucketName -u $DEFAULT_ADMIN -p $DEFAULT_PW --prefix=$prefix -c $collectionId "$loopFlag"
		if (( $? == 0 ));then
			return 0
		elif (( $? != 0 )) && (( $i != 2 ));then
			echo "Workloadgen resulted in error. Possibly system is loaded. Retry in 10 seconds"
			sleep 10
		fi
	done
}

function runCbWorkloadGenCollectionCont {
	local clusterName=$1
	local bucketName=$2
	local scopeName=$3
	local collectionName=$4

	# hacky - specially named prefix
	runCbWorkloadGenCollection "$clusterName" "$bucketName" "$scopeName" "$collectionName" "$CONTINUOUS_WORKLOAD_PREFIX"
}

function waitForBgJobs {
	echo "Waiting for background jobs to finish..."
	jobsCnt=`jobs -l | grep -c "Running"`
	while (( $jobsCnt > 0 ))
	do
		sleep 1
		jobsCnt=`jobs -l | grep -c "Running"`
	done
}

# Input: 1. clusterName
#        2. bucketName
function getManifest {
	local clusterName="$1"
	local bucketName="$2"
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	if [[ -z "${port:-}" ]];then
		echo ""
		return 1
	fi

	$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X GET http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$bucketName/collections
}

# Called hexString because input is in a form of double quoted string
# Also converts them to upper case because bc only takes A-F for hex
function hexStringToDec {
	local hexString=$1
	local hex=`echo "$hexString" | sed 's/"//g' | tr '[:lower:]' '[:upper:]'`

	echo "obase=10; ibase=16; $hex" | bc
}

function prettyPrintManifest {
	local manifest=$1
	local i

	# get manifest version
	local manifestVersion=`echo "$manifest" | jq '.uid'`
	local manifestVersionDec=`hexStringToDec $manifestVersion`
	echo "Manifest version $manifestVersionDec"

	#get all the scopes
	local scopesList=`echo "$manifest" | jq '.scopes'`
	local scopesListLen=`echo "$manifest" | jq '.scopes | length'`

	for (( i=0; $i < $scopesListLen; i=$(($i+1)) ))
	do
		local scopeOutput=`echo "$scopesList" | jq .[$i]`
		local scopeName=`echo "$scopeOutput" | jq '.name'`
		local scopeUID=`echo "$scopeOutput" | jq '.uid'`
		local scopeUIDdec=`hexStringToDec "$scopeUID"`
		echo "ScopeName $scopeName (UID $scopeUIDdec)"

		# Get individual collections within this scope
		local collectionsList=`echo "$scopeOutput" | jq '.collections'`
		local collectionsListLen=`echo "$scopeOutput" | jq '.collections | length'`
		for (( j=0; $j < $collectionsListLen; j=$(($j+1)) ))
		do
			local collectionsOutput=`echo "$collectionsList" | jq .[$j]`
			local collectionName=`echo "$collectionsOutput" | jq '.name'`
			local collectionUID=`echo "$collectionsOutput" | jq '.uid'`
			local collectionUIDdec=`hexStringToDec "$collectionUID"`
			echo "ScopeName $scopeName CollectionName $collectionName (UID $collectionUIDdec)"
		done
	done
}

# Returns non-0 if not found
function getCollectionIdFromScopeAndCollectionName {
	local manifest=$1
	local requestedScopeName=$2
	local requestedCollectionName=$3
	local i

	local scopesList=`echo "$manifest" | jq '.scopes'`
	local scopesListLen=`echo "$manifest" | jq '.scopes | length'`

	for (( i=0; $i < $scopesListLen; i=$(($i+1)) ))
	do
		local scopeOutput=`echo "$scopesList" | jq .[$i]`
		# Requested doesn't have double quotes, but manifest output does
		local scopeName=`echo "$scopeOutput" | jq '.name' | sed 's/"//g'`
		if [[ "$scopeName" == "$requestedScopeName" ]];then
			local collectionsList=`echo "$scopeOutput" | jq '.collections'`
			local collectionsListLen=`echo "$scopeOutput" | jq '.collections | length'`
			for (( j=0; $j < $collectionsListLen; j=$(($j+1)) ))
			do
				local collectionsOutput=`echo "$collectionsList" | jq .[$j]`
				# Requested doesn't have double quotes, but manifest output does
				local collectionName=`echo "$collectionsOutput" | jq '.name' | sed 's/"//g'`
				local collectionUID=`echo "$collectionsOutput" | jq '.uid'`
				local collectionUIDdec=`hexStringToDec "$collectionUID"`
				if [[ "$collectionName" == "$requestedCollectionName" ]];then
					echo "$collectionUIDdec"
					return 0
				fi
			done
		fi
	done

	# Not found
	echo ""
	return 1
}

function printSingleClusterBucketScopeAndCollection {
	local clusterName=$1
	local bucketName=$2

	# Get the manifest for this bucket
	local manifestOutput=""
	local manifestVersion=""
	manifestOutput=`getManifest $clusterName $bucketName`
	if (( $? != 0 ));then
		echo "Error retrieving manifest - Cluster $clusterName bucket $bucketName scope $scopeName"
		continue
	elif [[ -z "$manifestOutput" ]];then
		echo "Retrieved empty manifest JSON - Cluster $clusterName bucket $bucketName scope $scopeName"
		continue
	fi

	manifestVersion=`echo "$manifestOutput" | jq '.uid'`
	echo "Cluster $clusterName Bucket $bucketName collections manifest version: $manifestVersion"

	prettyPrintManifest "$manifestOutput"
}

# Print a summary of all the topology setup -> scope and collection info
# Uses the manifest REST API
function printGlobalScopeAndCollectionInfo {
	if (( `checkJQ` != 0 ));then
		echo "jq not found - cannot run $0"
		return 1
	fi

	for clusterName in `echo ${!CLUSTER_NAME_PORT_MAP[@]}`
	do
		local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}
		local -a buckets=(${CLUSTER_NAME_BUCKET_MAP[$clusterName]:-})
		for bucketName in `echo ${buckets[@]}`
		do
			printSingleClusterBucketScopeAndCollection "$clusterName" "$bucketName"
		done
	done
}

# Stats library

# Gets the last reading of the stats output
function getStats {
	local srcClusterName=$1
	local srcBucketName=$2
	local targetClusterName=$3
	local targetBucketName=$4
	local statsName=$5

	restId=`getRestIDFromExportedData "$srcClusterName" "$srcBucketName" "$targetClusterName" "$targetBucketName"`
	if (( $? != 0 ));then
		return $?
	fi

	local port=${CLUSTER_NAME_PORT_MAP[$srcClusterName]}
	if (( `checkJQ` != 0 ));then
		return 1
	fi

	statsOutput=`$CURL -u $DEFAULT_ADMIN:$DEFAULT_PW -X GET http://localhost:$port/$POOLS_DEFAULT_BUCKETS_PATH/$srcBucketName/stats/replications%2F${restId}%2F${statsName}`
	if (( $? != 0 ));then
		return $?
	fi

  # Stats output should only be only one stats with one node. Rolling window where last number is the latest:
  # {"samplesCount":60,"isPersistent":true,"lastTStamp":1595364466482,"interval":1000,
  # "timestamp":[1595364456473,1595364457474,1595364458475,1595364459476,1595364460477,1595364461478,1595364462478,1595364463479,1595364464480,1595364465481,1595364466482],
  # "nodeStats":{"127.0.0.1:9000":[7168,1057,0,0,0,0,0,0,0,0,0]}}
  # or
  # '{"samplesCount":60,"isPersistent":true,"lastTStamp":1595369104271,"interval":1000,
  # "timestamp":[1595369091258,1595369092259,1595369093260,1595369094261,1595369095262,1595369096263,1595369097264,1595369098265,1595369099266,1595369100267,1595369101268,1595369102269,1595369103270,1595369104271],
  # "nodeStats":{"[::1]:9000":[7168,1799,0,0,0,38,0,0,0,0,0,0,0,0]}}'
  echo "$statsOutput" | jq ".nodeStats" | jq '.[]' | jq '.[-1]'
}

function pauseReplication {
	local srcClusterName=$1
	local srcBucketName=$2
	local targetClusterName=$3
	local targetBucketName=$4

	restID=`getBucketReplicationRestID "$srcClusterName" "$srcBucketName" "$targetClusterName" "$targetBucketName"`
	if (( $? != 0 ));then
		echo "Unable to find REST ID"
		return 1
	fi
	local sourcePort=${CLUSTER_NAME_PORT_MAP[$srcClusterName]:-}
	if [[ -z "$sourcePort" ]];then
		echo "Unable to find admin port for cluster $srcClusterName"
		return 1
	fi

	echo "Pausing replication $restID"
	$CURL -X POST -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:${sourcePort}/settings/replications/${restID} -d pauseRequested=true > /dev/null 2>&1
}

function resumeReplication {
	local srcClusterName=$1
	local srcBucketName=$2
	local targetClusterName=$3
	local targetBucketName=$4

	restID=`getBucketReplicationRestID "$srcClusterName" "$srcBucketName" "$targetClusterName" "$targetBucketName"`
	if (( $? != 0 ));then
		echo "Unable to find REST ID"
		return 1
	fi
	local sourcePort=${CLUSTER_NAME_PORT_MAP[$srcClusterName]:-}
	if [[ -z "$sourcePort" ]];then
		echo "Unable to find admin port for cluster $srcClusterName"
		return 1
	fi

	echo "Resuming replication $restID"
	$CURL -X POST -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:${sourcePort}/settings/replications/${restID} -d pauseRequested=false > /dev/null 2>&1
}

declare INTERNAL_SETTINGS_REST_PATH="xdcr/internalSettings"

function listInternalSettings {
	local clusterName=$1
	local jqStr
	jqLocation=`which jq`
	if (( $? == 0 ));then
		jqStr="$jqLocation"
	fi
	importProvisionedConfig

	local port=${CLUSTER_NAME_XDCR_PORT_MAP[$clusterName]:-}
	if [[ -z "$port" ]];then
		echo "Invalid clustername $clusterName"
		return 1
	fi

	if [[ ! -z "$jqStr" ]];then
		$CURL -X GET -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:$port/$INTERNAL_SETTINGS_REST_PATH | $jqLocation
	else
		$CURL -X GET -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:$port/$INTERNAL_SETTINGS_REST_PATH
	fi
}

function setInternalSettings {
	local clusterName=$1
	local -a keyVal=("${@:2}")

	local jqStr
	jqLocation=`which jq`
	if (( $? == 0 ));then
		jqStr="$jqLocation"
	fi
	importProvisionedConfig

	local port=${CLUSTER_NAME_XDCR_PORT_MAP[$clusterName]:-}
	if [[ -z "$port" ]];then
		echo "Invalid clustername $clusterName"
		return 1
	fi

	# Because to do multiple -d keyvals, it's better to pass in a single array
	local -a curlMultiArr
	for kv in "${keyVal[@]}"
	do
		curlMultiArr+=(" -d ")
		curlMultiArr+=("$kv")
	done

	$CURL -X POST -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:$port/$INTERNAL_SETTINGS_REST_PATH ${curlMultiArr[@]} > /dev/null 2>&1
}

function getClusterLogs {
	local clusterName=$1
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}
	if [[ -z "$port" ]];then
		echo "Invalid clustername $clusterName"
		return 1
	fi

	$CURL -X GET -u $DEFAULT_ADMIN:$DEFAULT_PW http://127.0.0.1:$port/diag 2>&1
}
	
function getXDCRCheckpoints {
	local clusterName=$1
	local port=${CLUSTER_NAME_PORT_MAP[$clusterName]:-}

	checkpointOutput=`$CURL http://localhost:$port/diag/eval -d 'ns_server_testrunner_api:grab_all_goxdcr_checkpoints()' -u $DEFAULT_ADMIN:$DEFAULT_PW`
	if (( $? != 0 ));then
		return $?
	fi
	echo "$checkpointOutput"
}
